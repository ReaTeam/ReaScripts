noindex: true



desc:FXD Macros
import cookdsp.jsfx-inc

slider1:0<0,1>Macro 1
slider2:0<0,1>Macro 2
slider3:0<0,1>Macro 3
slider4:0<0,1>Macro 4
slider5:0<0,1>Macro 5
slider6:0<0,1>Macro 6
slider7:0<0,1>Macro 7
slider8:0<0,1>Macro 8
slider9:0<0,127>Morph 1
slider10:0<0,127>Morph 2
slider11:0<0,127>Morph 3
slider12:0<0,127>Morph 4
slider13:0<0,127>Morph 5
slider14:0<0,127>Morph 6
slider15:0<0,127>Morph 7
slider16:0<0,127>Morph 8


in_pin:none
out_pin:none

options:gmem=ParamValues
@init 
ext_noinit=1;
ext_midi_bus = 1;

midiamp = midinote = 0;


totalTrackCount =  gmem[0];
trkGUID_Num = gmem[1];


Mc1.Fol_Gain= 0.7 ; 
Mc2.Fol_Gain= 0.7 ; 
Mc3.Fol_Gain= 0.7 ; 
Mc4.Fol_Gain= 0.7 ; 
Mc5.Fol_Gain= 0.7 ; 
Mc6.Fol_Gain= 0.7 ; 
Mc7.Fol_Gain= 0.7 ; 
Mc8.Fol_Gain= 0.7 ; 



Mc1.SEQ_DNom = 1;
Mc1.SEQ_Leng = 8;
Mc2.SEQ_DNom = 1;
Mc2.SEQ_Leng = 8;
Mc3.SEQ_DNom = 1;
Mc3.SEQ_Leng = 8;
Mc4.SEQ_DNom = 1;
Mc4.SEQ_Leng = 8;
Mc5.SEQ_DNom = 1;
Mc5.SEQ_Leng = 8;
Mc6.SEQ_DNom = 1;
Mc6.SEQ_Leng = 8;
Mc7.SEQ_DNom = 1;
Mc7.SEQ_Leng = 8;
Mc8.SEQ_DNom = 1;
Mc8.SEQ_Leng = 8;

//gmem offsets ------------------------------
//gmem 1 = this track's DIY GUID
//gmem 2 = Selected track's Diy GUID
//gmem 3 = Prm Inst
//gmem 4 = if 1 then user is R-Dragging on prm
         //if 2 then user is adjusting env atk
         //if 3 then user is adjusting env rel
         //if 4.1 then Mod 1 is Env, 4.2 then Mod 2 is Env
        
         
//gmem 5 = Which Macro is user assigning
//gmem 6 = Which Param's mod range is user tweaking 
//gmem 7 = determine Param's value before modulaiton
//gmem 8 =  ? 
//gmem 9 = env1 atk      |   Follower Smoothness
//gmem 10 = env1 rel
//gmem 11 = env2 atk
//gmem 12 = env2 rel
//etc..24
//gmem 31~38 = Modulation type (Macro or Env)
//gmem 101~108 = send Modulation info back to imgui
//gmem 110 = SEQ Length or Denominator when user is tweaking 
//gmem 111 = SEQ Denominator when user is tweaking
//gmem 112 = step value of currently tweaking step
//gmem 121 ~128 = SEQ 1 ~ 8 Current Pos 



ModAmt = 1000;
ModAmt2 = 2000;
ModAmt3 = 3000;
ModAmt4 = 4000;
ModAmt5 = 5000;
ModAmt6 = 6000;
ModAmt7 = 7000;
ModAmt8 = 8000;
PsUsed = 100; 
P_OrigV = 11000 ;
SEQ = 20000; // 20001~20048 = Macro1 Seq 1~64

//------------------------------------------------------------
// TABLE INDEX ------------------------------
// 1,3,5,7,9,11,13,15 = envelope 1~8 's atk
// 2,4,6,8,10,12,14,16 = envelope 1~8 's rel



function fmod (n, k) (
    n - k * floor(n/k);
  );


midi_bus=15;   

Mc1.follow(10);
Mc2.follow(10);
Mc3.follow(10);
Mc4.follow(10);
Mc5.follow(10);
Mc6.follow(10);
Mc7.follow(10);
Mc8.follow(10);

Mc1.Macro = 1;
Mc2.Macro = 2;
Mc3.Macro = 3;
Mc4.Macro = 4;
Mc5.Macro = 5;
Mc6.Macro = 6;
Mc7.Macro = 7;
Mc8.Macro = 8;

Mc1.EnvToImGui = 101;
Mc2.EnvToImGui = 102;
Mc3.EnvToImGui = 103;
Mc4.EnvToImGui = 104;
Mc5.EnvToImGui = 105;
Mc6.EnvToImGui = 106;
Mc7.EnvToImGui = 107;
Mc8.EnvToImGui = 108;


function SendInfoBackToImGui()
(
  this.type =='step'?(
    (gmem[this.EnvToImGui] = SEQ[this.CurrentPos+1+64*(this.Macro-1)]*127);
  ):this.type =='env'?(
    gmem[this.EnvToImGui] = this.masr_do(midiamp)
  ):this.type =='Fol' ? (
    gmem[this.EnvToImGui] =  this.FOL_out*this.FOL_Gain*127;);
);


function SetMacroAttribute( x , y )
(
    //gmem[5] == this.Macro ? ( AAA = 'suc';  this.x = y ) ;
    Macro==1?(Mc1.FOL_Gain = y); 
    Macro==2?(Mc2.FOL_Gain = y); 
    Macro==3?(Mc3.FOL_Gain = y);
    Macro==4?(Mc4.FOL_Gain = y);
    Macro==5?(Mc5.FOL_Gain = y);
    Macro==6?(Mc6.FOL_Gain = y);
    Macro==7?(Mc7.FOL_Gain = y);
    Macro==8?(Mc8.FOL_Gain = y);
);

function CalculatMacroAmt(ModRange)
(
  ModRange!==0?(
    this.type =='step'?(
      this.CurrentPos = (beat_position * this.SEQ_DNom) % this.SEQ_Leng ;
      this.out = SEQ[this.CurrentPos+1+64*(this.Macro-1)]*127*ModRange  ;


    ):this.type =='env'?(

      this.masr_set_risetime(this.atk);
      this.masr_set_falltime(this.rel);
      this.out =  this.masr_do(midiamp)*ModRange;
      //trkGUID_Num === gmem[2]? (gmem[this.EnvToImGui] = this.masr_do(midiamp));



    ):this.type =='Fol' ? ( // if macro  is Follower 

      this.out = this.FOL_out*this.FOL_Gain *127*ModRange ;
    ):(   //if type is macro
      this.Out = this.Slider * ModRange*127);


  ):(this.Out = 0 );

);


function SetTypeTo (T)
(
  Macro = gmem[5];
  Macro==1?(Mc1.type=T); 
  Macro==2?(Mc2.type=T);
  Macro==3?(Mc3.Type=T);
  Macro==4?(Mc4.Type=T);
  Macro==5?(Mc5.Type=T);
  Macro==6?(Mc6.Type=T);
  Macro==7?(Mc7.Type=T);
  Macro==8?(Mc8.Type=T);
);





@slider
Mc1.Slider = slider1;
Mc2.Slider = slider2;
Mc3.Slider = slider3;
Mc4.Slider = slider4;
Mc5.Slider = slider5;
Mc6.Slider = slider6;
Mc7.Slider = slider7;
Mc8.Slider = slider8;

@sample 


Mc1.FOL_out  = Mc1.follow_do((spl0+spl1));
Mc2.FOL_out  = Mc2.follow_do((spl0+spl1));
Mc3.FOL_out  = Mc3.follow_do((spl0+spl1));
Mc4.FOL_out  = Mc4.follow_do((spl0+spl1));
Mc5.FOL_out  = Mc5.follow_do((spl0+spl1));
Mc6.FOL_out  = Mc6.follow_do((spl0+spl1));
Mc7.FOL_out  = Mc7.follow_do((spl0+spl1));
Mc8.FOL_out  = Mc8.follow_do((spl0+spl1));


@block
Sel_Trk_GUID_num = gmem[2];
// This will only execute once when playback starts
play_state === 0 ? (   
sendMidi = 0;
);  
play_state != 0 && sendMidi === 0 ? (
midi_bus=15;   
midisend(0, $x81, 30, 127); //Channel is the numb after $x9
sendMidi= 1;
);
// ----------------------------------------

//â–¼Send Midi Msg only when slider is moved or automated
Sldr9!=Slider9?( midisend(0, $xAF/*AfterTouch, 16th Chan*/, 1/*Which Note*/  , Slider9));
Sldr9=Slider9;

Sldr10!=Slider10?( midisend(0, $xAF/*AfterTouch, 16th Chan*/, 2/*Which Note*/  , Slider10));
Sldr10=Slider10;

Sldr11!=Slider11?( midisend(0, $xAF/*AfterTouch, 16th Chan*/, 3/*Which Note*/  , Slider11));
Sldr11=Slider11;

Sldr12!=Slider12?( midisend(0, $xAF/*AfterTouch, 16th Chan*/, 4/*Which Note*/  , Slider12));
Sldr12=Slider12;

Sldr13!=Slider13?( midisend(0, $xAF/*AfterTouch, 16th Chan*/, 5/*Which Note*/  , Slider13));
Sldr13=Slider13;

Sldr14!=Slider14?( midisend(0, $xAF/*AfterTouch, 16th Chan*/, 6/*Which Note*/  , Slider14));
Sldr14=Slider14;

Sldr15!=Slider15?( midisend(0, $xAF/*AfterTouch, 16th Chan*/, 7/*Which Note*/  , Slider15));
Sldr15=Slider15;

Sldr16!=Slider16?( midisend(0, $xAF/*AfterTouch, 16th Chan*/, 8/*Which Note*/  , Slider16));
Sldr16=Slider16;


mode= gmem[4];
midi_bus=15;   


//if user tweaking track that matches trkGUID
trkGUID_Num === gmem[2]? (
  Macro = gmem[5];
  mode ==1?(   // if User is right-dragging on param in ImGui...
    P.Inst = gmem[3];    
    Param = gmem[6];
    Macro = gmem[5];
    a[Param+ Macro*1000] = gmem[Param+ Macro*1000];
        
  );
  mode ==2?(   // if User is adjusting atk...  
    gmem[9] !=0?(Mc1.atk = gmem[9]); 
    gmem[11]!=0?(Mc2.atk = gmem[11]);  
    gmem[13]!=0?(Mc3.atk = gmem[13]);
    gmem[15]!=0?(Mc4.atk = gmem[15]);
    gmem[17]!=0?(Mc5.atk = gmem[17]);
    gmem[19]!=0?(Mc6.atk = gmem[19]);
    gmem[21]!=0?(Mc7.atk = gmem[21]);
    gmem[23]!=0?(Mc8.atk = gmem[23]);
    SetTypeTo ('env');                    
  );
  mode ==3?(   // if User is adjusting Release...
      gmem[10]!=0?(Mc1.Rel=gmem[10]);
      gmem[12]!=0?(Mc2.Rel=gmem[12]);
      gmem[14]!=0?(Mc3.Rel=gmem[14]);
      gmem[16]!=0?(Mc4.Rel=gmem[16]);
      gmem[18]!=0?(Mc5.Rel=gmem[18]);
      gmem[20]!=0?(Mc6.Rel=gmem[20]);
      gmem[22]!=0?(Mc7.Rel=gmem[22]);
      gmem[24]!=0?(Mc8.Rel=gmem[22]);
      SetTypeTo ('env');            
      );
  mode ==4?(   //if user ctrl-r-click and change type to Env...
    SetTypeTo ('env');
      );
  mode ==5? (   
    SetTypeTo ('Mc');
     );
  mode == 6? (  
    SetTypeTo ('step');
  );
  mode == 7 ? (  // if user is tweaking a step's Value
    SetTypeTo ('step');
    WhichStep= gmem[113]; 
    Macro==1?(
      SEQ[WhichStep]= gmem[112]; //writes seq value from table slot 20001~20048
    ):Macro==2?(    // //writes seq value from table slot 20065~20129
      SEQ[WhichStep+64]= gmem[112];  
    ):Macro==3?(    // //writes seq value from table slot 20065~20129
      SEQ[WhichStep+64*2]= gmem[112];  
    ):Macro==4?(    // //writes seq value from table slot 20065~20129
      SEQ[WhichStep+64*3]= gmem[112];  
    ):Macro==5?(    // //writes seq value from table slot 20065~20129
      SEQ[WhichStep+64*4]= gmem[112];  
    ):Macro==6?(    // //writes seq value from table slot 20065~20129
      SEQ[WhichStep+64*5]= gmem[112];  
    ):Macro==7?(    // //writes seq value from table slot 20065~20129
      SEQ[WhichStep+64*6]= gmem[112];  
    ):Macro==8?(    // //writes seq value from table slot 20065~20129
      SEQ[WhichStep+64*7]= gmem[112];  
    );
  
  );

  mode == 8 ? (// if user is changing Sequencer Lenth or note length...
    Macro = gmem[5];
    Macro==1?( //if user is tweaking macro 1
      gmem[110] != 0 ? (Mc1.SEQ_Leng = gmem[110];    gmem[110] = 0) ; 
      gmem[111] != 0 ? (Mc1.SEQ_DNom = gmem[111];    gmem[111] = 0);
    ):Macro==2?(
      gmem[110] != 0 ? (Mc2.SEQ_Leng = gmem[110];    gmem[110] = 0); 
      gmem[111] != 0 ? (Mc2.SEQ_DNom = gmem[111];    gmem[111] = 0);
    ):Macro==3?(
      gmem[110] != 0 ? (Mc3.SEQ_Leng = gmem[110];    gmem[110] = 0); 
      gmem[111] != 0 ? (Mc3.SEQ_DNom = gmem[111];    gmem[111] = 0);
    ):Macro==4?(
      gmem[110] != 0 ? (Mc4.SEQ_Leng = gmem[110];    gmem[110] = 0); 
      gmem[111] != 0 ? (Mc4.SEQ_DNom = gmem[111];    gmem[111] = 0);
    ):Macro==5?(
      gmem[110] != 0 ? (Mc5.SEQ_Leng = gmem[110];    gmem[110] = 0); 
      gmem[111] != 0 ? (Mc5.SEQ_DNom = gmem[111];    gmem[111] = 0);
    ):Macro==6?(
      gmem[110] != 0 ? (Mc6.SEQ_Leng = gmem[110];    gmem[110] = 0); 
      gmem[111] != 0 ? (Mc6.SEQ_DNom = gmem[111];    gmem[111] = 0);
    ):Macro==7?(
      gmem[110] != 0 ? (Mc7.SEQ_Leng = gmem[110];    gmem[110] = 0); 
      gmem[111] != 0 ? (Mc7.SEQ_DNom = gmem[111];    gmem[111] = 0);
    ):Macro==8?(
      gmem[110] != 0 ? (Mc8.SEQ_Leng = gmem[110];    gmem[110] = 0); 
      gmem[111] != 0 ? (Mc8.SEQ_DNom = gmem[111];    gmem[111] = 0);
    );
  );

  mode == 9? (
    SetTypeTo('Fol')

  );

  mode == 10 ? (
     // sets smoothness
    Macro = gmem[5];
    Macro==1?(Mc1.follow_set_freq(gmem[9]));
    Macro==2?(Mc2.follow_set_freq(gmem[9]));
    Macro==3?(Mc3.follow_set_freq(gmem[9]));
    Macro==4?(Mc4.follow_set_freq(gmem[9]));
    Macro==5?(Mc5.follow_set_freq(gmem[9]));
    Macro==6?(Mc6.follow_set_freq(gmem[9]));
    Macro==7?(Mc7.follow_set_freq(gmem[9]));
    Macro==8?(Mc8.follow_set_freq(gmem[9]));

  );
  mode == 11 ? (




    Macro==1?(Mc1.FOL_Gain = gmem[9];); 
    Macro==2?(Mc2.FOL_Gain = gmem[9];); 
    Macro==3?(Mc3.FOL_Gain = gmem[9];);
    Macro==4?(Mc4.FOL_Gain = gmem[9];);
    Macro==5?(Mc5.FOL_Gain = gmem[9];);
    Macro==6?(Mc6.FOL_Gain = gmem[9];);
    Macro==7?(Mc7.FOL_Gain = gmem[9];);
    Macro==8?(Mc8.FOL_Gain = gmem[9];);
  );
      
  gmem[7] != 0?( // if user uses Imgui to tweak param...
    P_Id = gmem[7];
    P_OrigV[P_Id]= gmem[11000+P_Id];
    what=gmem[8];
    gmem[8] != 0?( // if paramV + Mod is over 1...
      a[Param+ Macro*1000] = gmem[Param+ Macro*1000]
    );
   
  );




  MeasureNum= floor(beat_position/ts_denom);

  

  beat_pos = play_position * tempo ; 



  BeatPos= beat_position - ts_denom* (MeasureNum);



  beat_per_block = beat_per_spl * samplesblock;
  beat_per_block *= speed;
  next_block_pos = fmod(bp + beat_per_block, sequence_length);

); // --------------------- End of if track is selected -----------------------




while (midirecv(offset, msg1, msg2, msg3)) (
  // get noteons and noteoffs from all channels
  (msg1 & $xF0) == $x90 || (msg1 & $xF0) == $x80 ? (
      msg3 != 0 ? (
          // noteon 
          midinote = msg2;
          
          // msg3 == Velocity
          midiamp =  128; // /msg33   // if you want Velocity involved use msg 3
          midisend(offset,msg1,msg2,msg3);
      ) : (
          // noteoff
          msg2 == midinote ? midiamp = 0;
          midisend(offset,msg1,msg2,msg3);
      );
  ) : (
      // passthrough other events
      midisend(offset,msg1,msg2,msg3);
  );
);
 
i=1;    
while ( i <= P.Inst)(
  
  


  Mc1.CalculatMacroAmt(ModAmt[i]);
  Mc2.CalculatMacroAmt(ModAmt2[i]);
  Mc3.CalculatMacroAmt(ModAmt3[i]);
  Mc4.CalculatMacroAmt(ModAmt4[i]);
  Mc5.CalculatMacroAmt(ModAmt5[i]);
  Mc6.CalculatMacroAmt(ModAmt6[i]);
  Mc7.CalculatMacroAmt(ModAmt7[i]);
  Mc8.CalculatMacroAmt(ModAmt8[i]);
  
  ModAmtTotal = Mc1.Out+Mc2.Out+Mc3.Out+Mc4.Out+Mc5.Out+Mc6.Out+Mc7.Out+Mc8.Out;
  
  SendAmt = P_OrigV[i]*127 + ModAmtTotal;

  SendAmt > 127 ? (SendAmt = 127) ;
    
  midisend(0, $xBf, i, SendAmt);
      
  i+=1;
);


///  ---------------- Send info back to ImGui ------------------ 
trkGUID_Num === gmem[2]? (
  loop(8, 
  m+=1;
  Mc1.SendInfoBackToImGui();
  Mc2.SendInfoBackToImGui();
  Mc3.SendInfoBackToImGui();
  Mc4.SendInfoBackToImGui();
  Mc5.SendInfoBackToImGui();
  Mc6.SendInfoBackToImGui();
  Mc7.SendInfoBackToImGui();
  Mc8.SendInfoBackToImGui();

  );
);
  
  










//------------------------------------------------------------------------------------------------


while (midirecv(offset, msg1, msg2, msg3)) (
    // get noteons and noteoffs from all channels
    (msg1 & $xF0) == $x90 || (msg1 & $xF0) == $x80 ? (
        msg3 != 0 ? (
            // noteon 
            midinote = msg2;
            // Normalizes amplitude value
            midiamp = msg3 / 94;
            time = time_precise();
            Aa_TestEnv = 1;
            
            
        ) : (
            // noteoff
            msg2 == midinote ? midiamp = 0;
        );
    ) : (
        // passthrough other events
        midisend(offset,msg1,msg2,msg3);
    );
);


    
