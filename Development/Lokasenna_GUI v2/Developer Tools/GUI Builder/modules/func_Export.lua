-- NoIndex: true
------------------------------------
-------- File export functions -----
-------- for GUI Builder -----------
------------------------------------

--local Element = require("func_Elements")
local Export = {}


function Export.get_filename_to_export()

    local disp_path = string.len(GUI.script_path) > 28
                    and ("..." .. string.sub(GUI.script_path, -25))
                    or  GUI.script_path

    ::get_file::

    local ret, file_name = reaper.GetUserInputs( "Export", 1, disp_path .. ",extrawidth=80", "exported_GUI.lua")

    if not ret then return end

    if reaper.file_exists( GUI.script_path .. file_name ) then
        ret = reaper.ShowMessageBox("Do you want to overwrite the existing file?", "File exists", 3)

        -- Yes = 6, No = 7, Cancel = 2
        if ret == 7 then
            goto get_file
        elseif ret == 2 then
            return nil
        end

    end

    return GUI.script_path .. file_name

end


function Export.generate_file_header()

    local tmp = {}

    tmp[1] = "-- Script generated by Lokasenna's GUI Builder\n\n"

    tmp[2] = [=[
local lib_path = reaper.GetExtState("Lokasenna_GUI", "lib_path_v2")
if not lib_path or lib_path == "" then
    reaper.MB("Couldn't load the Lokasenna_GUI library. Please install 'Lokasenna's GUI library v2 for Lua', available on ReaPack, then run the 'Set Lokasenna_GUI v2 library path.lua' script in your Action List.", "Whoops!", 0)
    return
end
loadfile(lib_path .. "Core.lua")()
]=]

    return tmp

end





-- Sort the list of elements by z
function Export.sort_elm_strs(elm_strs)

    local z_max = 0
    for k in pairs(elm_strs) do
        if k > z_max then z_max = k end
    end

    local sorted = {}
    for i = 1, z_max do

        if elm_strs[i] then

            for j = 1, #elm_strs[i] do

                sorted[#sorted + 1] = elm_strs[i][j]

            end

            sorted[#sorted + 1] = "\n\n"

        end

    end

    return sorted

end


-- Get a list of user elements and generate 'GUI.New(...' strings for them
function Export.get_elements_to_export(elms)

    local elm_strs = {}
    local props, extra_props, strs
    local params

    for k, elm in pairs(elms) do

        if string.match(k, "GB_") then goto next end

        props = Element.get_elm_params(elm)

        -- Remove the Menu bar's offset, since we're exporting
        if props.y then props.y = props.y - Menu.h end

        local params = GUI[elm.type].GB.properties

        strs = {}

        local started
        for i = 1, #params do
            if params[i].prop == "z" then
                started = true

            end
            if started and params[i].prop then
                strs[#strs+1] = "    " .. params[i].prop .. " = " .. tostring(props[params[i].prop])
            end
        end
        str =   "GUI.New(" .. props.name .. ", " .. Element.format_property_to_code(elm.type) .. ", {\n" ..
                table.concat(strs, ",\n") ..
                "\n})\n"


        -- Store strings separately by z so we can sort them
        if not elm_strs[elm.z] then elm_strs[elm.z] = {} end
        table.insert(elm_strs[elm.z], str)

        ::next::

    end

    return Export.sort_elm_strs(elm_strs)

end


function Export.get_required_classes(strs)

    -- Iterate through all of the new element strings and extract their classes
    local classes = {}
    local new_elm, class
    for k, v in pairs(strs) do

        new_elm = string.match(v, "GUI%.New.-\n")

        if new_elm then

            class = string.match(new_elm, ", [\'\"](.-)[\'\"],")

            if class then

                classes[class] = true

            end

        end

    end

    -- Both of these classes use the same file (Option)
    if classes.Radio or classes.Checklist then
        classes.Radio, classes.Checklist = nil, nil
        classes.Options = true
    end

    local pre, post = [[GUI.req("]], [[.lua")()]]
    local strs = {}

    for k in pairs(classes) do

        -- *** MAKE LIB_PATH A USER PREFERENCE ***
        -- *** MAKE THIS NOT REQUIRE REQS? ***
        strs[#strs + 1] = pre .. "Classes/Class - " .. k .. post

    end

    -- Add an error check
    strs[#strs + 1] = [[-- If any of the requested libraries weren't found, abort the script.
if missing_lib then return 0 end]]

    return strs

end


-- Compile the project's GUI.title, GUI.w, etc, etc
function Export.get_window_params()

    local params = {}
    local wnd = Project.proj_settings

    params[1] = [[GUI.name = "]] .. wnd.name .. [["]]
    params[2] = "GUI.x, GUI.y, GUI.w, GUI.h = " ..
                wnd.x .. ", " .. wnd.y .. ", " .. wnd.w .. ", " .. wnd.h
    params[3] = [[GUI.anchor, GUI.corner = "]] .. wnd.anchor .. [[", "]] .. wnd.corner .. [["]]

    return params

end


function Export.generate_file_to_export()

    local header = Export.generate_file_header()
    local elms = Export.get_elements_to_export(GUI.elms)
    local reqs = Export.get_required_classes(elms)

    local wnd = Export.get_window_params()

    -- ***Make sure to include comment headings/separators***

    -- Make sure to leave blank space between each z (z_sets?)

    -- Init and Main
    local footer = "GUI.Init()\nGUI.Main()"

    local contents = {

        table.concat(header, "\n"),
        "\n\n\n\n",
        table.concat(reqs, "\n"),
        "\n\n\n\n",
        table.concat(wnd, "\n"),
        "\n\n\n\n",
        table.concat(elms, "\n"),
        "\n\n\n\n",
        footer

    }

    return contents

end


function Export.export_file()

    local path = Export.get_filename_to_export()
    if not path then return end

    local contents = Export.generate_file_to_export()

    local file, err = io.open(path, "w")
    if not file then
        reaper.MB("Could't open file to write:\n" .. tostring(err), "Oops!", 0)
        return
    end

    file:write(table.concat(contents), "\n")
    file:close()

end

return Export